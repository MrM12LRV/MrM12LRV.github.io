
<h1> TITLE </h1>
Cython Automatic Loop Parallelization <br/>
Joey Fernau                    <br/>

<h1> SUMMARY </h1>
Summarize your project in no more than 2-3 sentences. Describe what you plan to do and what parallel systems you will be working with. Example one-liners include (you should add a bit more detail):

I'm going to implement dependence testing for Cython, a typed superset of Python that compiles to C, in order to perform automatic loop parallelization.  The parallel systems include C++ vector instrinsics (available from Cython's native C++ calls) and/or OpenMP; the testing will be run on CPUs and/or GPUs.

<h1> BACKGROUND </h1>
If your project involves accelerating a compute-intensive application, describe the application or piece of the application you are going to implement in more detail. This description need only be a few paragraphs. It might be helpful to include a block diagram or pseudocode of the basic idea. An important detail is what aspects of the problem might benefit from parallelism? and why?

  Python is known to suffer from performance issues; <a href="http://cython.org/"> Cython </a> is an optimizing static compiler for both Python and Cython. This project will be able to take any valid Python program, analyze its abstract syntax tree using the <a href="https://docs.python.org/2/library/ast.html"> ast module </a> by performing <a href="https://en.wikipedia.org/wiki/Loop_dependence_analysis"> Array Dependence Analysis </a> in order to determine if a loop can be parallelized.  Cython can be converted into LLVM's IR, so we can also perform analysis on this representation if Python's ast library does not prove to be sufficient for this project.
  <br/>

  The process of determining this type of dependence is called dependence testing.  There are many types of dependence testers, such as Lamport's Test, the GCD test, Banerjee's Inequalities, the Power Test, the I-Test, the Omega Test, the Delta Test, the Stanford Test, and so on...  Some are
  less computationally expensive, but are more conservative approximations and thus may not be able to detect independence of all parallelizable loops.



<h1> THE CHALLENGE </h1>
Describe why the problem is challenging. What aspects of the problem might make it difficult to parallelize? In other words, what to you hope to learn by doing the project?

  This problem is challenging because of the nature of the problem -- automatically inferring if a loop has independent iterations reduces down to solving an integer linear program, which is NP-hard.  Thus, we must make conservative estimates.  It will be very cool to do program analysis with the end result of automatic parallelization.  This is a neat field to study, and mythical automatic parallizing compiler is one beast researchers are hunting for.
  <br/>

  I interesting to see how well the different dependence testers fair with respect to determining if a loop is parallelizable.
  <br/>

  The workload of this project is any given Python program.  Some programs are more difficult to analyze than others.  For example, a quadruply nested for loop with hundreds of iterations per loop would be a difficult integer linear program to solve.  Thus, the conservative estimates may not
  be able to determine that the loop is parallelizable.

<h1> RESOURCES </h1>
Describe the resources (type of computers, starter code, etc.) you will use. What code base will you start from? Are you starting from scratch or using an existing piece of code? Is there a book or paper that you are using as a reference (if so, provide a citation)? Are there any other resources you need, but haven't figured out how to obtain yet? Could you benefit from access to any special machines?

I will be using Python 2.7, Cython, Python's ast library, LLVM (possibly), C/C++.  Other than that, I will be starting from scratch.  The machines I will be using will be the GHC machines since they are mulicore.  I may potentially benefit from a machine with more cores to have neater test results, but I do not find that completely necessary.

To learn about Array Dependence Analysis am using the Purple Dragon Book: <br/>
Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman.
Compilers: Principles, Techniques, and Tools (2nd Edition).
Pearson Addison Wesley, 2006. ISBN: 978-0321486814.
<br/>

I may use other sources in order to implement the other conservative dependence testers, but I am not sure what those are yet.


<h1> GOALS AND DELIVERABLES </h1>
Describe the deliverables or goals of your project.

This is by far the most important section of the proposal:

Separate your goals into what you PLAN TO ACHIEVE (what you believe you must get done to have a successful project and get the grade you expect) and an extra goal or two that you HOPE TO ACHIEVE if the project goes really well and you get ahead of schedule. It may not be possible to state precise performance goals at this time, but we encourage you be as precise as possible. If you do state a goal, give some justification of why you think you can achieve it. (e.g., I hope to speed up my starter code 10x, because if I did it would run in real-time.)
If applicable, describe the demo you plan to show at the parallelism computation (will it be an interactive demo? will you show an output of the program that is really neat? will you show speedup graphs?). Specifically, what will you show us that will demonstrate you did a good job?
If your project is an analysis project, what are you hoping to learn about the workload or system being studied? What question(s) do you plan to answer in your analysis?
Systems project proposals should describe what the system will be capable of and what performance is hoped to be achieved.
IN GENERAL: Imagine that I didn't give you a grading script on assignments 2, 3, or 4. Imagine you did the entire assignment, made it as fast as you could, and then turned it in. You wouldn't have any idea if you'd done a good job!!! That's the situation you are in for the final project. And that's the situation I'm in when grading your final project. As part of your project plan, and ONE OF THE FIRST THINGS YOU SHOULD DO WHEN YOU GET STARTED WORKING is implement the test harnesses and/or baseline "reference" implementations for your project. Then, for the rest of your project you always have the ability to run your optimized code and obtain a comparison.

<h1> PLATFORM CHOICE </h1>
Describe why the platform (computer and/or language) you have chosen is a good one for your needs. Why does it make sense to use this parallel system for the workload you have chosen?

<h1> SCHEDULE </h1>
Produce a schedule for your project. Your schedule should have at least one item to do per week. List what you plan to get done each week from now until the parallelism competition in order to meet your project goals. Keep in mind that due to other classes, you'll have more time to work some weeks than others (work that into the schedule). You will need to re-evaluate your progress at the end of each week and update this schedule accordingly. Note the intermediate checkpoint deadline is April 25th. In your schedule we encourage you to be precise as precise as possible. It's often helpful to work backward in time from your deliverables and goals, writing down all the little things you'll need to do (establish the dependencies!).

